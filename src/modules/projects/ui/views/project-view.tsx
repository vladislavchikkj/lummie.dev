'use client'

import {
  Copy,
  ExternalLinkIcon,
  RefreshCcwIcon,
  CodeIcon,
  EyeIcon,
  FileCode2,
  Construction,
  XIcon,
} from 'lucide-react'
import {
  Suspense,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react'
import { ErrorBoundary } from 'react-error-boundary'

import { Fragment } from '@/generated/prisma'
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from '@/components/ui/resizable'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Button } from '@/components/ui/button'
import { Hint } from '@/components/hint'

import { MessagesContainer } from '../components/messages-container'
import { FragmentWeb } from '../components/fragment-web'
import { FileExplorer } from '@/components/file-explorer/file-explorer'
import { Separator } from '@/components/ui/separator'
import { Navbar } from '@/modules/home/ui/components/navbar/navbar'
import { useSuspenseQuery } from '@tanstack/react-query'
import { useTRPC, useTRPCClient } from '@/trpc/client'
import { MessageForm } from '@/modules/projects/ui/components/message-form'
import { TRPCClientError } from '@trpc/client'

interface Props {
  projectId: string
}

const PreviewPlaceholder = () => (
  <div className="bg-muted/40 text-muted-foreground flex h-full w-full flex-col items-center justify-center rounded-lg border border-dashed">
    <Construction size={48} strokeWidth={1} />
    <p className="mt-4 text-center text-lg font-medium">
      Preview will appear here
    </p>
    <p className="text-sm">Generate or select a fragment to see the result.</p>
  </div>
)

const CodePlaceholder = () => (
  <div className="bg-muted/40 text-muted-foreground flex h-full w-full flex-col items-center justify-center rounded-lg border border-dashed">
    <FileCode2 size={48} strokeWidth={1} />
    <p className="mt-4 text-center text-lg font-medium">No code to display</p>
    <p className="text-sm">Select a fragment to browse its files.</p>
  </div>
)

export const CHAT_ROLES = {
  USER: 'USER' as const,
  ASSISTANT: 'ASSISTANT' as const,
}

export const CHAT_MESSAGE_TYPES = {
  ERROR: 'ERROR' as const,
  RESULT: 'RESULT' as const,
}

export interface ChatMessageEntity {
  id: string
  content: string
  role: 'USER' | 'ASSISTANT'
  type: 'RESULT' | 'ERROR'
  createdAt: Date
  fragment: Fragment | null
  isFirst?: boolean
}

type DisplayedMessageEntity = ChatMessageEntity & { isStreaming?: boolean }

export const ProjectView = ({ projectId }: Props) => {
  const [activeFragment, setActiveFragment] = useState<Fragment | null>(null)
  const [tabState, setTabState] = useState<'preview' | 'code'>('preview')
  const [assistantMessageType, setAssistantMessageType] = useState<
    'CHAT' | 'PROJECT'
  >('CHAT')

  const [copied, setCopied] = useState(false)
  const [fragmentKey, setFragmentKey] = useState(0)

  const hasSubmittedFirstMessage = useRef(false)
  const lastMessageWithFragmentIdRef = useRef<string | null>(null)

  const [messages, setMessages] = useState<ChatMessageEntity[]>([])
  const [streamingContent, setStreamingContent] = useState<string>('')
  const [isStreaming, setIsStreaming] = useState<boolean>(false)
  const [pendingUserMessage, setPendingUserMessage] =
    useState<ChatMessageEntity | null>(null)
  const [lastMessageCount, setLastMessageCount] = useState<number>(0)
  const [wasStreamAborted, setWasStreamAborted] = useState<boolean>(false)
  const [isAborting, setIsAborting] = useState<boolean>(false)
  const [streamingCompleted, setStreamingCompleted] = useState<boolean>(false)

  const trpc = useTRPC()
  const trpcClient = useTRPCClient()
  const abortControllerRef = useRef<AbortController | null>(null)

  const { data: initialMessages, refetch } = useSuspenseQuery(
    trpc.messages.getMany.queryOptions(
      { projectId: projectId },
      {
        refetchOnMount: false,
        refetchOnWindowFocus: false,
        refetchInterval: isStreaming ? false : 5000,
      }
    )
  )

  const onSubmit = useCallback(
    async (message: string, isFirstMessage: boolean = false) => {
      console.log('üöÄ onSubmit called:', {
        message: message.substring(0, 50),
        isFirstMessage,
        isStreaming,
      })

      if (isStreaming || !message.trim()) return

      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π AbortController —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π –±—ã–ª –æ—á–∏—â–µ–Ω
      if (!abortControllerRef.current) {
        abortControllerRef.current = new AbortController()
      }

      const userMsg: ChatMessageEntity = {
        role: CHAT_ROLES.USER,
        content: message,
        id: `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        createdAt: new Date(),
        fragment: null,
        type: CHAT_MESSAGE_TYPES.RESULT,
      }

      if (!isFirstMessage) {
        setPendingUserMessage(userMsg)
      }

      console.log('üìù Setting streaming state:', {
        isStreaming: true,
        streamingContent: '',
        wasStreamAborted: false,
        currentMessagesCount: messages.length,
      })
      setIsStreaming(true)
      setStreamingContent('')
      setWasStreamAborted(false)
      setStreamingCompleted(false)

      try {
        const stream = await trpcClient.projects.handleUserMessage.mutate(
          {
            projectId: projectId,
            value: message,
            isFirst: isFirstMessage,
          },
          {
            signal: abortControllerRef.current.signal,
          }
        )

        for await (const { content, type } of stream) {
          console.log('üì¶ Stream chunk received:', {
            content: content.substring(0, 50),
            type,
          })
          setAssistantMessageType((prev) => {
            if (type !== prev) {
              console.log('üîÑ Assistant message type changed:', {
                from: prev,
                to: type,
              })
              return type
            }
            return prev
          })
          setStreamingContent((prev) => {
            const newContent = prev + content
            console.log('üìù Streaming content updated:', {
              prevLength: prev.length,
              newLength: newContent.length,
              content: newContent.substring(0, 100),
            })
            return newContent
          })
        }
      } catch (error) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        const isAbortError =
          (error instanceof TRPCClientError &&
            (error.data?.code === 'CLIENT_CLOSED_REQUEST' ||
              error.cause?.name === 'AbortError')) ||
          (error instanceof Error && error.name === 'AbortError') ||
          (error as { name?: string })?.name === 'AbortError'

        if (isAbortError) {
          console.log('üõë Stream aborted by user:', { wasStreamAborted: true })
          setWasStreamAborted(true)
          // –ù–µ –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –∫–∞–∫ –æ—à–∏–±–∫–∏
          console.debug('Stream aborted by user')
        } else {
          console.error('Streaming error:', error)
        }
      } finally {
        console.log('üèÅ Finally block:', {
          isStreaming: false,
          wasStreamAborted,
          streamingContentLength: streamingContent.length,
        })

        setIsStreaming(false)
        setIsAborting(false)

        // –ë–µ–∑–æ–ø–∞—Å–Ω–æ –æ—á–∏—â–∞–µ–º abort controller
        if (abortControllerRef.current) {
          abortControllerRef.current = null
        }

        // –ù–µ –º–µ–Ω—è–µ–º assistantMessageType –µ—Å–ª–∏ —Å—Ç—Ä–∏–º –±—ã–ª –ø—Ä–µ—Ä–≤–∞–Ω
        // setAssistantMessageType –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å

        // –ù–µ –¥–µ–ª–∞–µ–º refetch —Å—Ä–∞–∑—É - —ç—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä –∏ –ø—Ä–æ–ø–∞–¥–∞–Ω–∏–µ —Å—Ç—Ä–∏–º–∞
        // –ù–ï –æ—á–∏—â–∞–µ–º pendingUserMessage —Å—Ä–∞–∑—É - –æ–Ω –¥–æ–ª–∂–µ–Ω –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ—Ä–≤–µ—Ä–∞

        // –û—Ç–º–µ—á–∞–µ–º —á—Ç–æ —Å—Ç—Ä–∏–º –∑–∞–≤–µ—Ä—à–µ–Ω, –Ω–æ –ù–ï –æ—á–∏—â–∞–µ–º streamingContent
        // —á—Ç–æ–±—ã –æ–Ω –æ—Å—Ç–∞–≤–∞–ª—Å—è –≤–∏–¥–∏–º—ã–º –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ—Ä–≤–µ—Ä–∞
        setStreamingCompleted(true)
        if (wasStreamAborted) {
          setWasStreamAborted(false)
        }

        // –î–µ–ª–∞–µ–º refetch –≤ —Ñ–æ–Ω–µ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ UI
        // –ù–æ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π, —á—Ç–æ–±—ã –¥–∞—Ç—å –≤—Ä–µ–º—è UI –æ–±–Ω–æ–≤–∏—Ç—å—Å—è
        setTimeout(() => {
          refetch().catch(console.error)
        }, 100)
      }
    },
    [
      projectId,
      isStreaming,
      refetch,
      trpcClient.projects.handleUserMessage,
      wasStreamAborted,
      streamingContent,
      messages.length,
    ]
  )

  useEffect(() => {
    console.log('üîÑ useEffect for initialMessages:', {
      hasInitialMessages: !!initialMessages,
      initialMessagesLength: initialMessages?.length,
      isStreaming,
      lastMessageCount,
      hasSubmittedFirstMessage: hasSubmittedFirstMessage.current,
    })

    if (initialMessages) {
      const lastMessage = initialMessages[initialMessages.length - 1]
      const isUserFirstMsg =
        lastMessage?.isFirst && lastMessage.role === CHAT_ROLES.USER

      if (isUserFirstMsg && !hasSubmittedFirstMessage.current) {
        console.log(
          'üöÄ Processing first message:',
          lastMessage.content.substring(0, 50)
        )
        setMessages(initialMessages.slice(0, -1))
        setLastMessageCount(initialMessages.length - 1)
        onSubmit(lastMessage.content, true)
        hasSubmittedFirstMessage.current = true
      } else {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏:
        // 1. –ù–µ –∏–¥–µ—Ç —Å—Ç—Ä–∏–º–∏–Ω–≥ –ò
        // 2. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑–º–µ–Ω–∏–ª–æ—Å—å (–Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ—è–≤–∏–ª–∏—Å—å)
        // 3. –ò –ù–ï –±—ã–ª–æ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Å—Ç—Ä–∏–º–∞ (—á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ª–∏—à–Ω–∏—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π)
        const shouldUpdate =
          !isStreaming &&
          initialMessages.length !== lastMessageCount &&
          initialMessages.length > lastMessageCount &&
          !wasStreamAborted

        console.log('üìä Message update decision:', {
          shouldUpdate,
          isStreaming,
          initialMessagesLength: initialMessages.length,
          lastMessageCount,
          lengthChanged: initialMessages.length !== lastMessageCount,
          lengthIncreased: initialMessages.length > lastMessageCount,
        })

        if (shouldUpdate) {
          console.log('‚úÖ Updating messages from server:', {
            oldCount: messages.length,
            newCount: initialMessages.length,
            streamingContent: streamingContent.substring(0, 50),
            wasStreamAborted,
            streamingCompleted,
          })

          // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å—Ç—Ä–∏–º-—Å–æ–æ–±—â–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
          const filteredMessages = initialMessages.filter(
            (msg) => !msg.id.startsWith('temp-streaming-')
          )

          setMessages(filteredMessages)
          setLastMessageCount(filteredMessages.length)

          // –û—á–∏—â–∞–µ–º streamingContent –∏ pendingUserMessage –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ—Ä–≤–µ—Ä–∞
          if (streamingCompleted) {
            setStreamingContent('')
            setStreamingCompleted(false)
            setPendingUserMessage(null)
          }
        } else {
          console.log('‚è∏Ô∏è Skipping message update due to streaming')
        }
      }
    }
  }, [
    initialMessages,
    onSubmit,
    isStreaming,
    lastMessageCount,
    wasStreamAborted,
    messages.length,
    streamingContent,
    streamingCompleted,
  ])

  const onRefreshPreview = () => {
    setFragmentKey((prev) => prev + 1)
  }

  const handleStopStreaming = () => {
    console.log('üõë handleStopStreaming called:', {
      hasAbortController: !!abortControllerRef.current,
      isAborted: abortControllerRef.current?.signal.aborted,
      isStreaming,
      isAborting,
      streamingContentLength: streamingContent.length,
    })

    if (
      abortControllerRef.current &&
      !abortControllerRef.current.signal.aborted &&
      isStreaming &&
      !isAborting
    ) {
      console.log('üõë Aborting stream...')
      setIsAborting(true)
      try {
        abortControllerRef.current.abort()
        console.log('‚úÖ Stream abort signal sent')
      } catch (error) {
        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–∏ —Å—Ç—Ä–∏–º–∞
        console.debug('Stream aborted:', error)
      }
    } else {
      console.log('‚ùå Cannot abort stream:', {
        hasAbortController: !!abortControllerRef.current,
        isAborted: abortControllerRef.current?.signal.aborted,
        isStreaming,
        isAborting,
      })
    }
  }

  const handleCopyUrl = () => {
    if (!activeFragment?.sandboxUrl) return
    navigator.clipboard.writeText(activeFragment.sandboxUrl)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  const displayedMessages = useMemo((): DisplayedMessageEntity[] => {
    console.log('üé≠ displayedMessages recalculated:', {
      messagesCount: messages.length,
      pendingUserMessage: !!pendingUserMessage,
      streamingContent: streamingContent.substring(0, 50),
      streamingContentLength: streamingContent.length,
      isStreaming,
      wasStreamAborted,
    })

    const allMessages: DisplayedMessageEntity[] = [...messages]

    if (pendingUserMessage) {
      allMessages.push(pendingUserMessage)
    }

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä–∏–º–∏–Ω–≥ –∫–æ–Ω—Ç–µ–Ω—Ç –µ—Å–ª–∏:
    // 1. –ò–¥–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º –ò–õ–ò
    // 2. –ï—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç –æ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞ (–ø–æ–∫–∞ –Ω–µ –ø—Ä–∏—à–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å —Å–µ—Ä–≤–µ—Ä–∞)
    const shouldShowStreamingContent =
      streamingContent && (isStreaming || streamingCompleted)

    if (shouldShowStreamingContent) {
      const streamingMessage = {
        id: `streaming-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        createdAt: new Date(),
        fragment: null,
        role: CHAT_ROLES.ASSISTANT,
        content: streamingContent,
        type: CHAT_MESSAGE_TYPES.RESULT,
        isStreaming: isStreaming, // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞
      }
      console.log('üì§ Adding streaming message to display:', {
        content: streamingContent.substring(0, 100),
        isStreaming,
      })
      allMessages.push(streamingMessage)
    } else {
      console.log('‚ùå Not showing streaming content:', {
        hasStreamingContent: !!streamingContent,
        isStreaming,
        wasStreamAborted,
        messagesCount: messages.length,
      })
    }

    console.log('üìã Final displayedMessages count:', allMessages.length)
    return allMessages
  }, [
    messages,
    pendingUserMessage,
    streamingContent,
    isStreaming,
    wasStreamAborted,
    streamingCompleted,
  ])

  useEffect(() => {
    const lastMessageWithFragment = displayedMessages.findLast(
      (message) => !!message.fragment
    )

    if (
      lastMessageWithFragment?.fragment &&
      lastMessageWithFragment.id !== lastMessageWithFragmentIdRef.current
    ) {
      setActiveFragment(lastMessageWithFragment.fragment)
      lastMessageWithFragmentIdRef.current = lastMessageWithFragment.id
    }
  }, [displayedMessages, setActiveFragment])

  return (
    <div className="flex h-dvh flex-col pt-14">
      <Navbar showDesktopNav={false} applyScrollStyles={false} />

      <ResizablePanelGroup direction="horizontal" className="flex-1">
        <ResizablePanel
          defaultSize={activeFragment ? 35 : 100}
          minSize={25}
          className="relative flex min-h-0 flex-col overflow-hidden"
        >
          <ErrorBoundary
            fallback={<p className="text-destructive p-2">Messages Error</p>}
          >
            <Suspense fallback={null}>
              <MessagesContainer
                activeFragment={activeFragment}
                setActiveFragment={setActiveFragment}
                messages={displayedMessages || []}
                projectCreating={
                  assistantMessageType !== 'CHAT' && !wasStreamAborted
                }
                isStreaming={isStreaming}
              >
                <MessageForm
                  key={activeFragment ? 'narrow' : 'wide'}
                  projectId={projectId}
                  onStop={handleStopStreaming}
                  isStreaming={isStreaming}
                  // onSubmit={() => {}}
                  onSubmit={onSubmit}
                />
              </MessagesContainer>
            </Suspense>
          </ErrorBoundary>

          <div className="from-background pointer-events-none absolute top-0 right-0 left-0 z-10 h-6 bg-gradient-to-b to-transparent" />
        </ResizablePanel>

        {activeFragment && (
          <>
            <ResizableHandle withHandle className="bg-transparent" />
            <ResizablePanel defaultSize={65} minSize={50} className="min-h-0">
              <Tabs
                className="flex h-full flex-col gap-0"
                defaultValue="preview"
                value={tabState}
                onValueChange={(value) =>
                  setTabState(value as 'preview' | 'code')
                }
              >
                <div className="flex h-14 flex-none items-center justify-between gap-x-2 rounded-tl-lg border-t border-b border-l px-2">
                  <TabsList className="h-9 rounded-md border bg-transparent p-1">
                    <TabsTrigger value="preview" className="h-full text-sm">
                      <EyeIcon className="size-4" />
                    </TabsTrigger>
                    <TabsTrigger value="code" className="h-full text-sm">
                      <CodeIcon className="size-4" />
                    </TabsTrigger>
                  </TabsList>

                  {tabState === 'preview' && activeFragment && (
                    <div className="flex min-w-0 flex-1 items-center justify-end gap-x-2">
                      <div className="group bg-muted/60 relative flex h-9 flex-1 items-center gap-2 rounded-md border">
                        <Hint text="Refresh Preview" side="bottom">
                          <Button
                            size="icon"
                            variant="ghost"
                            onClick={onRefreshPreview}
                          >
                            <RefreshCcwIcon className="size-4" />
                          </Button>
                        </Hint>
                        <span className="text-muted-foreground truncate font-mono text-sm">
                          {activeFragment.sandboxUrl ?? 'URL not available'}
                        </span>
                        <Hint
                          text={copied ? 'Copied!' : 'Copy URL'}
                          side="bottom"
                        >
                          <Button
                            size="icon"
                            variant="ghost"
                            className="absolute top-1/2 right-2 h-7 w-7 -translate-y-1/2"
                            onClick={handleCopyUrl}
                            disabled={!activeFragment.sandboxUrl}
                          >
                            <Copy className="size-4" />
                          </Button>
                        </Hint>
                      </div>

                      <Hint text="Open in a new tab" side="bottom">
                        <Button
                          size="icon"
                          variant="ghost"
                          disabled={!activeFragment.sandboxUrl}
                          asChild
                        >
                          <a
                            href={activeFragment.sandboxUrl ?? '#'}
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <ExternalLinkIcon className="size-4" />
                          </a>
                        </Button>
                      </Hint>
                    </div>
                  )}
                  <div className="flex h-full w-fit items-center justify-center gap-2">
                    <Separator orientation="vertical" className="h-6" />

                    <Hint text="Close Panel" side="bottom">
                      <Button
                        size="icon"
                        variant="ghost"
                        onClick={() => setActiveFragment(null)}
                      >
                        <XIcon className="size-4" />
                      </Button>
                    </Hint>
                  </div>
                </div>

                <TabsContent
                  value="preview"
                  className="flex-1 overflow-auto border-l"
                >
                  {activeFragment ? (
                    <FragmentWeb
                      data={activeFragment}
                      refreshKey={fragmentKey}
                    />
                  ) : (
                    <PreviewPlaceholder />
                  )}
                </TabsContent>

                <TabsContent
                  value="code"
                  className="flex-1 overflow-auto border-l"
                >
                  {activeFragment?.files ? (
                    <FileExplorer
                      files={activeFragment.files as { [path: string]: string }}
                      projectId={projectId}
                    />
                  ) : (
                    <div className="h-full p-4">
                      <CodePlaceholder />
                    </div>
                  )}
                </TabsContent>
              </Tabs>
            </ResizablePanel>
          </>
        )}
      </ResizablePanelGroup>
    </div>
  )
}
